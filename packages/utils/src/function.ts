import { isFunction } from './is';
import { AnyFn, EnsureParameters } from './type';

/**
 * cache the result of function by first parameter
 * @param fn 
 * @returns 
 */
/*@__NO_SIDE_EFFECTS__*/
export const cacheFunctionByKey = <T extends (str: string) => unknown>(fn: T): T => {
  const cache: Record<string, unknown> = Object.create(null);
  return ((str: string) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  }) as T;
};

/**
 * cache the result of function by parameters, the cache key is generated by `parameters.join('')`
 * @param fn
 * @returns
 */
/*@__NO_SIDE_EFFECTS__*/
export const cacheFunctionByParams = <T extends (...args: any[]) => any>(fn: T) => {
  const cache: Record<string, ReturnType<T>> = {};
  return ((...args: Parameters<T>): ReturnType<T> => {
    const key = args.join(''), hit = cache[key];
    if (hit != null) return hit;
    else return (cache[key] = fn(...args));
  }) as T;
};

export function runIfFn<T, Args extends EnsureParameters<T, any[]> = EnsureParameters<T, any[]>>(
  target: T,
  ...args: Args
): T extends AnyFn ? ReturnType<T> : T {
  return isFunction(target) ? target(...args) : (target as any);
}

export function once<T extends AnyFn>(fn: T): T {
  let called = false,
    result: ReturnType<T>;
  return function (this: any, ...args: Parameters<T>) {
    if (called) return result;
    called = true;
    return (result = fn.apply(this, args));
  } as T;
}

export function noop() { }
