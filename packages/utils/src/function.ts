import { isFunction } from './is';
import { AnyFn, EnsureParameters, ExcludeNonFunc } from './type';
import { ensureArray } from './array';

/**
 * cache the result of function by first parameter
 * @param fn
 * @returns
 */
/*@__NO_SIDE_EFFECTS__*/
export function cacheFunctionByKey<T extends (str: string) => unknown>(fn: T): T {
  const cache: Record<string, unknown> = Object.create(null);
  return ((str: string) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  }) as T;
}

/**
 * cache the result of function by parameters, the cache key is generated by `parameters.join('')`
 * @param fn
 * @returns
 */
/*@__NO_SIDE_EFFECTS__*/
export function cacheFunctionByParams<T extends (...args: any[]) => any>(fn: T) {
  const cache: Record<string, ReturnType<T>> = {};
  return ((...args: Parameters<T>): ReturnType<T> => {
    const key = args.join(''),
      hit = cache[key];
    if (hit != null) return hit;
    else return (cache[key] = fn(...args));
  }) as T;
}

export function runIfFn<T, Args extends any[] = EnsureParameters<ExcludeNonFunc<T>, any[]>>(
  target: T,
  ...args: NoInfer<Args>
): T extends AnyFn ? ReturnType<T> : T {
  return isFunction(target) ? target(...args) : (target as any);
}

export function once<T extends AnyFn>(fn: T): T {
  let called = false,
    result: ReturnType<T>;
  return function (this: any, ...args: Parameters<T>) {
    if (called) return result;
    called = true;
    return (result = fn.apply(this, args));
  } as T;
}

export function noop() {}

export function pipe(this: any, ...fnOrArgs: unknown[]) {
  let args: unknown[] = [];
  for (const arg of fnOrArgs) {
    if (isFunction(arg)) {
      args = ensureArray(arg.apply(this, args));
    } else args.push(arg);
  }
  return args;
}
