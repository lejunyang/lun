import {
  debounce,
  isElement,
  toArrayIfNotNil,
  on,
  off,
  noop,
  isEditElement,
  getDeepestActiveElement,
  inBrowser,
  getWindow,
  isNode,
  toHostIfSlot,
  runIfFn,
  prevent,
  intersectOrHas,
} from '@lun/utils';
import { computed, reactive, ref, watchEffect } from 'vue';
import { VirtualElement, tryOnScopeDispose, useClickOutside } from '../../hooks';
import { MaybeRefLikeOrGetter, unrefOrGet } from '../../utils';
import { useListen } from './useListen';

export type PopoverTrigger = 'hover' | 'focus' | 'edit' | 'click' | 'contextmenu' | 'select' | 'pointerdown';

export interface PopoverAttachTargetOptions {
  isDisabled?: MaybeRefLikeOrGetter<boolean>;
}

export type UsePopoverOptions = {
  /** manually control the open state of popover */
  open?: boolean;
  disabled?: MaybeRefLikeOrGetter<boolean>;
  onOpen: () => void | boolean;
  beforeOpen?: () => void | boolean;
  target: MaybeRefLikeOrGetter<Element | VirtualElement>;
  pop: MaybeRefLikeOrGetter<Element>;
  triggers?: PopoverTrigger | PopoverTrigger[];
  openDelay?: number | string;
  closeDelay?: number | string;
  toggleMode?: boolean;
  targetFocusThreshold?: number;
  preventSwitchWhen?: 'focus' | 'edit';
  pointerTarget?: 'rect' | 'coord';
  onPopContentClose?: (e: Event) => void;
};

export function usePopover(_options: UsePopoverOptions) {
  const isOpen = ref(false),
    /** it's for animation; isOpen: false => animation ends => isShow: false */ isShow = ref(false),
    isCloseScheduling = ref(false);
  const isClosing = computed(() => isCloseScheduling.value || (!isOpen.value && isShow.value));
  const virtualTarget = ref<
    | (VirtualElement & {
        /**
         * this flag indicates the virtual target is generated by pointer or not.
         * it's to prevent selection clearing the target generated by pointer as selection target and pointer target share the virtualTarget ref.
         */
        _p?: boolean;
      })
    | null
    | undefined
  >();

  let ensureClose: boolean | undefined = false; // flag used to ensure delayed close
  const options = computed(() => {
    let { openDelay = 0, closeDelay = 120, onOpen, triggers, disabled, beforeOpen } = _options;
    const performOpen = () => {
      if (unrefOrGet(disabled) || unrefOrGet(isOpen) || runIfFn(beforeOpen) === false) return;
      const result = onOpen();
      if (result !== undefined) isShow.value = isOpen.value = result;
    };
    const performClose = () => {
      isOpen.value = false;
      ensureClose = false;
    };

    const dOpen = debounce(performOpen, openDelay),
      dClose = debounce(performClose, closeDelay, { onSchedulingUpdate: (v) => (isCloseScheduling.value = v) });
    triggers = toArrayIfNotNil(triggers!);
    if (!triggers.length) triggers = ['hover', 'click', 'edit'];
    const cancelOpenOrClose = () => {
      dOpen.cancel();
      dClose.cancel();
    };
    return {
      targetFocusThreshold: 20,
      get manual() {
        return _options.open !== undefined;
      },
      triggers: new Set<PopoverTrigger>(triggers),
      cancelOpenOrClose,
      open() {
        if (ensureClose === true) return;
        dClose.cancel();
        dOpen();
        events?.onOpen();
      },
      close(ensure?: boolean) {
        dOpen.cancel();
        dClose();
        ensureClose = ensure;
      },
      openNow() {
        cancelOpenOrClose();
        performOpen();
      },
      closeNow() {
        cancelOpenOrClose();
        performClose();
      },
      toggleNow(force?: boolean) {
        cancelOpenOrClose();
        if (!isOpen.value || (!force && force !== undefined)) performOpen();
        else if (isOpen.value || force) performClose();
      },
    };
  });

  const events = useListen({
    // always open parent when child opens, it's for nested type=teleport popover
    onOpen: () => options.value.open(),
    // we can't close parent when child closes, should use onPopContentClose and let parent to handle it
    // onClose: () => options.value.close(),
  });

  // handle manual open control by external
  watchEffect(() => {
    const { manual, openNow, closeNow } = options.value;
    if (manual) {
      if (_options.open) openNow();
      else closeNow();
    }
  });

  /** create a event handler representing a pop trigger with action method */
  const createTrigger =
    (
      trigger: PopoverTrigger | null | Set<PopoverTrigger>,
      method: 'open' | 'close' | 'toggle',
      /** return false to prevent trigger; return open or close to change the default method */
      extraHandle?: (e: Event, actualMethod: 'open' | 'close') => void | boolean | 'open' | 'close',
    ) =>
    (e: Event) => {
      const { triggers, manual } = options.value;
      // 'edit' same as 'focus'
      if ((!trigger || intersectOrHas(triggers, trigger) || (trigger === 'focus' && triggers.has('edit'))) && !manual) {
        let actualMethod =
          method === 'toggle' ? (_options.toggleMode && unrefOrGet(isShow) ? 'close' : 'open') : method;
        let temp: any = '';
        if (extraHandle && (temp = extraHandle(e, actualMethod)) === false) return;
        const finalMethod = (options.value as any)[temp] || options.value[actualMethod];
        // clear selection target
        if (trigger !== 'select' && finalMethod === 'open' && !virtualTarget.value?._p) virtualTarget.value = null;
        finalMethod();
      }
    };

  let popFocusIn = false,
    ignoreTargetFocusout = false;
  /** focusing elements inside popover target, or popover target itself */
  const focusSet = new WeakSet<EventTarget>(),
    focusDeepestElMap = new WeakMap<Element, Element>();

  /** determine whether to prevent closing pop content(checkTrigger=true) or prevent switching pop target(checkTrigger=false) when has focus */
  const needPrevent = (e: Event, checkTrigger = true) => {
    const { triggers } = options.value,
      { preventSwitchWhen } = _options;
    const deepEl = getDeepestActiveElement()!;
    return (
      unrefOrGet(isShow) &&
      (popFocusIn || focusSet.has(e.target!) || focusSet.has(deepEl)) &&
      ((checkTrigger ? triggers.has('focus') : preventSwitchWhen === 'focus') ||
        ((checkTrigger ? triggers.has('edit') : preventSwitchWhen === 'edit') && isEditElement(deepEl)))
    );
  };

  // ------------------ extra targets ------------------
  // it's to support attaching events of triggering popover on other elements in an imperative manner
  const extraTargetsMap = reactive(new Map<Element, ReturnType<typeof createTargetHandlers>>()),
    extraTargetsOptionMap = new WeakMap<Element, PopoverAttachTargetOptions>();
  const activeExtraTarget = ref(),
    activeExtraTargetOptions = computed(() => extraTargetsOptionMap.get(activeExtraTarget.value));
  const methods = {
    attachTarget(target?: Element, options: PopoverAttachTargetOptions = {}) {
      if (!isElement(target) || extraTargetsMap.has(target)) return;
      const targetHandlers = createTargetHandlers((e, method) => {
        if (method === 'open') {
          if (unrefOrGet(options.isDisabled)) return false;
          // consider pointerdown also as focusin, or pointerdown can be prevented because of needPrevent when switching targets
          if (e.type !== 'focusin' && e.type !== 'pointerdown' && needPrevent(e, false)) {
            return false;
          }
          activeExtraTarget.value = target;
        }
        // no need to clear activeTarget when close, as every open will reset activeTarget
      });
      extraTargetsMap.set(target, targetHandlers);
      extraTargetsOptionMap.set(target, options);
      for (const [key, handler] of Object.entries(targetHandlers)) {
        on(target, key.slice(2).toLowerCase(), handler);
      }
    },
    detachTarget(target?: Element) {
      if (!isElement(target)) return;
      const targetHandlers = extraTargetsMap.get(target);
      if (!targetHandlers) return;
      for (const [key, handler] of Object.entries(targetHandlers)) {
        off(target, key.slice(2).toLowerCase(), handler);
      }
      extraTargetsMap.delete(target);
      extraTargetsOptionMap.delete(target);
      if (target === activeExtraTarget.value) {
        options.value.closeNow();
        activeExtraTarget.value = null;
      }
    },
    detachAll() {
      for (const target of extraTargetsMap.keys()) {
        methods.detachTarget(target);
      }
    },
  };
  tryOnScopeDispose(methods.detachAll);
  // ------------------ extra targets ------------------

  const createTargetHandlers = (onTrigger: (e: Event, actualMethod: 'open' | 'close') => void | boolean = noop) => {
    let targetFocusInTime = 0,
      targetFocusOutTime = 0,
      pointerDownTime = 0;

    const activatePointerTarget = (e: MouseEvent, triggerResult?: boolean | void) => {
      if (triggerResult !== false && _options.pointerTarget === 'coord') {
        // do not use clientX, use offsetX + target rect x instead, in case target updates its position
        const tx = e.offsetX,
          ty = e.offsetY,
          t = e.target as Element;
        virtualTarget.value = {
          _p: true,
          getBoundingClientRect() {
            // always get new rect
            const { x, y } = t.getBoundingClientRect();
            const fx = tx + x,
              fy = ty + y;
            return {
              width: 0,
              height: 0,
              x: fx,
              y: fy,
              top: fy,
              left: fx,
              right: fx,
              bottom: fy,
            };
          },
        };
      } else virtualTarget.value = undefined;
      return triggerResult;
    };

    const pointerdownClose = createTrigger('pointerdown', 'close', onTrigger);
    const targetHandlers = {
      onMouseenter: createTrigger('hover', 'open', onTrigger),
      onMouseleave: createTrigger('hover', 'close', (e, m) => {
        return !needPrevent(e) && onTrigger(e, m) !== false;
      }),
      // need to use pointer down to trigger toggle before focusin
      onPointerdown: createTrigger(new Set(['click', 'pointerdown']), 'toggle', (e, m) => {
        pointerDownTime = e.timeStamp;
        // focusin should be triggered after pointerdown
        // but found an exception... if we focus on target and then focus other place outside viewport(like browser address input or console input), then click target again
        // it will fire focusin first and then pointerdown, no idea why...
        // so prevent focusin firing when it's before pointerdown
        const { targetFocusThreshold } = options.value;
        if (pointerDownTime - targetFocusInTime < targetFocusThreshold) return false;
        return activatePointerTarget(e as MouseEvent, onTrigger(e, m));
      }),
      onPointerup: pointerdownClose,
      onPointerleave: pointerdownClose,
      onPointercancel: pointerdownClose,
      onContextmenu: createTrigger('contextmenu', 'open', (e, m) => {
        prevent(e);
        return activatePointerTarget(e as MouseEvent, onTrigger(e, m));
      }),
      onFocusin: createTrigger('focus', 'open', (e, m) => {
        targetFocusInTime = e.timeStamp;
        const target = e.target as Element,
          cur = e.currentTarget as Element,
          deep = getDeepestActiveElement()!;
        focusSet.add(target);
        focusSet.add(cur); // it's to prevent hiding in other events like mouseleave. their target may differ, but currentTarget is always the popover target
        focusSet.add(deep); // it's to prevent switching when focus or edit, use deepest element because custom-element can be inside another custom-element
        focusDeepestElMap.set(target, deep);

        // if we click suffix icon when input is focused and toggleMode is true, it will fire pointerdown(toggle close) -> focusout -> focusin(open). close will be canceled
        // we need to prevent this
        // if (targetFocusInTime - pointerDownTime < options.value.targetFocusThreshold) return false; // targetFocusInTime - pointerDownTime is not reliable, it can be 10+ms or 20+ms, use isShow instead
        // if (unrefOrGet(options.value.isShow) && !extraTargetsMap.value.has(e.currentTarget as any)) return false;
        if (isClosing.value && !extraTargetsMap.has(cur)) {
          return false;
        }
        return onTrigger(e, m);
      }),
      onFocusout: createTrigger('focus', 'close', (e, m) => {
        targetFocusOutTime = e.timeStamp;
        const target = e.target as Element,
          cur = e.currentTarget as Element,
          deep = focusDeepestElMap.get(target)!;
        focusSet.delete(target);
        focusSet.delete(deep);
        focusSet.delete(cur);
        const { targetFocusThreshold } = options.value;
        if (ignoreTargetFocusout || targetFocusOutTime - pointerDownTime < targetFocusThreshold) return false;
        return onTrigger(e, m);
      }),
    };
    return targetHandlers;
  };

  const handlePopShow = createTrigger(null, 'open'),
    contentClose = (e: Event) => _options.onPopContentClose?.(e),
    pointerdownClose = createTrigger('pointerdown', 'close', contentClose);
  const popContentHandlers = {
    onMouseenter: handlePopShow,
    onMouseleave: createTrigger('hover', 'close', (e) => {
      const res = !needPrevent(e);
      if (res !== false) contentClose(e);
      return res;
    }),
    // focusin bubbles, while focus doesn't
    onFocusin: createTrigger(null, 'open', () => {
      popFocusIn = true;
    }),
    onFocusout: createTrigger(null, 'close', (e) => {
      popFocusIn = false;
      contentClose(e);
    }),
    // need use pointerdown instead of click, because if we press the pop content and don't release, popover target will fire focusout and then close, click will not be triggered on pop content
    onPointerdown(e: Event) {
      ignoreTargetFocusout = true;
      // to make sure it's after focusout
      setTimeout(() => {
        handlePopShow(e);
      });
    },
    onPointerup: pointerdownClose,
    onPointerleave: pointerdownClose,
    onPointercancel: pointerdownClose,
  };

  // ------------------ selection ------------------
  const handleSelect = createTrigger('select', 'open', (e) => {
    const selection = getWindow(e.target as any).getSelection();
    if (!selection || selection.type !== 'Range') {
      // virtualTarget.value = null; // do not clear virtualTarget here, if we clear it, actual pop target will update and then position shifts. we delay it to next open in createTrigger.
      return 'close';
    }
    // options.value.target is a slot element, seems that slot element is always false when calling containsNode, so we need to get the host element
    const target = [toHostIfSlot(unrefOrGet(_options.target)), ...extraTargetsMap.keys()].find(
      (e) => isNode(e) && selection.containsNode(e, true),
    );
    if (target) {
      virtualTarget.value = selection.getRangeAt(0);
    } else {
      // virtualTarget.value = null;
      return 'close';
    }
  });
  inBrowser && tryOnScopeDispose(on(document, 'selectionchange', handleSelect));
  // ------------------ selection ------------------

  const cleanup = useClickOutside(
    computed(() =>
      // Array.from(extraTargetsMap.value.keys()).concat(options.value.target as any, options.value.pop as any),
      [activeExtraTarget.value, _options.target, _options.pop],
    ),
    () => {
      options.value.close();
      ignoreTargetFocusout = false;
    },
    () => {
      const { manual } = options.value;
      return unrefOrGet(isShow) && !manual;
    },
  );
  return {
    targetHandlers: createTargetHandlers((_, method) => {
      if (method === 'open') activeExtraTarget.value = null;
    }),
    popContentHandlers,
    options,
    cleanup,
    methods,
    activeExtraTarget,
    activeExtraTargetOptions,
    /** current valid selection range or pointer target ref */
    virtualTarget,
    isOpen,
    isShow,
    isClosing,
  };
}
